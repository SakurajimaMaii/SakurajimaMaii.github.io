<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bug缔造者</title>
  
  <subtitle>你的压力来源于，你无法自律，只是假装努力，现状跟不上内心的欲望，所以你焦虑又恐慌。</subtitle>
  <link href="https://www.entropy2020.cn/atom.xml" rel="self"/>
  
  <link href="https://www.entropy2020.cn/"/>
  <updated>2022-11-29T13:35:01.151Z</updated>
  <id>https://www.entropy2020.cn/</id>
  
  <author>
    <name>Vast Gui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日记（2022-11-29）</title>
    <link href="https://www.entropy2020.cn/2022/11/29/diary/diary_2022_11_29/"/>
    <id>https://www.entropy2020.cn/2022/11/29/diary/diary_2022_11_29/</id>
    <published>2022-11-29T13:20:56.000Z</published>
    <updated>2022-11-29T13:35:01.151Z</updated>
    
    <content type="html"><![CDATA[<p>今天把线性代数的矩阵部分的知识点总结完毕了，后续应该还要经常回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天把线性代数的矩阵部分的知识点总结完毕了，后续应该还要经常回顾。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="日记" scheme="https://www.entropy2020.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="https://www.entropy2020.cn/2022/11/28/linear_algebra/matrix/"/>
    <id>https://www.entropy2020.cn/2022/11/28/linear_algebra/matrix/</id>
    <published>2022-11-28T14:55:56.000Z</published>
    <updated>2022-11-29T13:31:14.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵的概念和运算"><a href="#矩阵的概念和运算" class="headerlink" title="矩阵的概念和运算"></a>矩阵的概念和运算</h2><h3 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h3><ol><li><p>矩阵的概念<br> $m*n$个数排成如下$m$行$n$列的表格，</p><script type="math/tex; mode=display"> \begin{bmatrix} a_{11} & a_{12}  & \cdots & a_{1n}      \\ a_{21} & a_{22}  & \cdots & a_{2n}      \\ \vdots & \vdots & \vdots \\ a_{m1} & a_{m2}  & \cdots & a_{mn}      \\ \end{bmatrix}</script><p> 称为是一个$m<em>n$的矩阵，当$m=n$的时候，称为<strong>n阶矩阵</strong>或者<em>*n阶方阵</em></em>。</p></li><li><p>零矩阵<br> 当一个矩阵的所有元素都为0的时候称为<strong>零矩阵</strong>，记作<strong>0</strong>。</p><script type="math/tex; mode=display"> \begin{bmatrix} 0 & 0  & \cdots & 0     \\ 0 & 0  & \cdots & 0    \\ \vdots & \vdots & \vdots \\ 0 & 0  & \cdots & 0     \\ \end{bmatrix}</script></li><li><p>同型矩阵<br> 两个矩阵行数和列数都相等称为<strong>同型矩阵</strong>。</p></li><li><p>矩阵相等<br> 两个同型矩阵对应的元素都相等称为<strong>矩阵AB相等，记作A=B</strong>。</p></li></ol><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><ol><li><p>相加<br> 两个同型矩阵可以相加</p><script type="math/tex; mode=display">A+B=[a_{ij}]_{m*n}+[b_{ij}]_{m*n}=[a_{ij}+b_{ij}]_{m*n}</script></li><li><p>数乘<br> 设$k$是数，则有</p><script type="math/tex; mode=display">kA=k[a_{ij}]_{m*n}=[ka_{ij}]_{m*n}</script></li><li><p>乘法</p><script type="math/tex; mode=display">c_{ij}=\sum_{k=1}^s a_{ik}b_{kj}=a_{i1}b_{1j}+a_{i2}b_{2j}+....+a_{is}b_{sj}</script><blockquote><p>注意点</p><pre><code> 1. $AB \ne BA$ 2. $AB=0 \nRightarrow A=0或B=0$ 3. $AB=AC,A \ne 0 \nRightarrow B=C$</code></pre></blockquote></li><li><p>关于$\alpha\beta^T$，$\beta\alpha^T$，$\alpha^T\beta$，$\beta^T\alpha$</p><p> 注意$\alpha\alpha^T$是<strong>对称矩阵</strong></p></li><li><p>转置<br> 将$m×n$型矩阵$A=[a<em>{ij}]</em>{m<em>n}$的行列互换得到的$n×m$矩阵$A[a<em>{ji}]</em>{n</em>m}$称为A的转置矩阵，记为$A^T$，即若</p><script type="math/tex; mode=display">A= \begin{bmatrix} a_{11} & a_{12}  \\ a_{21} & a_{22}   \end{bmatrix}</script><p> 则有</p><script type="math/tex; mode=display">A^T= \begin{bmatrix} a_{11} & a_{21}  \\ a_{12} & a_{22}   \end{bmatrix}</script></li><li><p>矩阵多项式<br> 设A是$n$阶矩阵，$f(x)=a<em>mx^m+…+a_1x+a_0$是x的多项式，则称$a_mA^m十a</em>{m-1}A^{m-1}+…十a_1A十a_0E$为矩阵多项式，记为 $f(A)$。</p></li><li><p>运算法则<br> (1) 加法</p><pre><code> $A+B=B+A$ $(A+B)+C=A+(B+C)$ $A+0=A$ $A+(-A)=0$</code></pre><p> (2) 数乘矩阵</p><pre><code> $k(mB)=(km)A$ $(k+m)A=kA+mA$ $k(A+B)=kA+kB$ $0A=0$</code></pre><p> (3) 乘法</p><pre><code> $(AB)C=A(BC)$ $A(B+C)=AB+AC$ $(A+B)C=AC+BC$</code></pre><p> (4) 转置</p><pre><code> $(A+B)^T=A^T+B^T$ $(kA)^T=kA^T$ $(AB)^T=B^TA^T$ $(A^T)^T=A$</code></pre></li></ol><h3 id="常见的矩阵"><a href="#常见的矩阵" class="headerlink" title="常见的矩阵"></a>常见的矩阵</h3><ol><li><p>单位矩阵<br> 单位矩阵用$E$表示</p><script type="math/tex; mode=display"> \begin{bmatrix} 1 & 0  \\ 0 & 1   \end{bmatrix}</script></li><li><p>数乘矩阵<br> 数$k$和单位矩阵$E$的积$kE$称为数量阵</p></li><li><p>对角矩阵</p><script type="math/tex; mode=display"> \begin{bmatrix} a_1 & 0  \\ 0 & a_2   \end{bmatrix} \begin{bmatrix} b_1 & 0  \\ 0 & b_2   \end{bmatrix} = \begin{bmatrix} a_1b_1 & 0  \\ 0 & a_2b_2   \end{bmatrix}</script><p> 对角矩阵的注意事项<br> (1) $AB=BA$<br> (2) $$</p><pre><code> \begin&#123;bmatrix&#125; a_1 &amp; 0  \\ 0 &amp; a_2   \end&#123;bmatrix&#125;^n = \begin&#123;bmatrix&#125; a_1^n &amp; 0  \\ 0 &amp; a_2^n   \end&#123;bmatrix&#125; $$</code></pre><p> (3) $$</p><pre><code> \begin&#123;bmatrix&#125; a_1 &amp; 0  \\ 0 &amp; a_2   \end&#123;bmatrix&#125;^&#123;-1&#125; = \begin&#123;bmatrix&#125; \frac&#123;1&#125;&#123;a_1&#125; &amp; 0  \\ 0 &amp; \frac&#123;1&#125;&#123;a_2&#125; \end&#123;bmatrix&#125; $$</code></pre></li><li><p>上（下）三角阵<br> 当$i&gt;j(i&lt;j)$时，有$a_{ij}$的矩阵称为上（下）三角阵</p><script type="math/tex; mode=display"> \begin{bmatrix} 1 & 0 & 0\\ 2 & 3 & 0\\ 4 & 5 & 6   \end{bmatrix}</script><script type="math/tex; mode=display"> \begin{bmatrix} 1 & 2 & 3\\ 0 & 4 & 5\\ 0 & 0 & 6   \end{bmatrix}</script></li><li><p>对称阵<br> 满足$A^T=A$的对称阵</p></li><li><p>反对称阵<br> 满足$A^T=-A$的对称阵</p></li></ol><h2 id="伴随矩阵、可逆矩阵"><a href="#伴随矩阵、可逆矩阵" class="headerlink" title="伴随矩阵、可逆矩阵"></a>伴随矩阵、可逆矩阵</h2><h3 id="伴随矩阵的概念与公式"><a href="#伴随矩阵的概念与公式" class="headerlink" title="伴随矩阵的概念与公式"></a>伴随矩阵的概念与公式</h3><ol><li><p>伴随矩阵的概念</p><p> 对于矩阵$A$对应的行列式$|A|$所有代数余子式构成的形如</p><script type="math/tex; mode=display"> \begin{bmatrix} A_{11} & A_{12}  & \cdots & A_{1n}      \\ A_{21} & A_{22}  & \cdots & A_{2n}      \\ \vdots & \vdots & \vdots \\ A_{m1} & A_{m2}  & \cdots & A_{mn}      \\ \end{bmatrix}</script><p> 称为矩阵$A$的伴随矩阵，记作$A^*$</p></li><li><p>伴随矩阵的公式</p><ol><li>$AA^<em>=A^</em>A=|A|E$<blockquote><p>由此可以得出$A^*=|A|A^{-1}$</p></blockquote></li><li>$(A^<em>)^{-1}=(A^{-1})^</em>=\frac{1}{|A|}A$</li><li>$(kA)^<em>=k^{n-1}A^</em>$</li><li>$(A^<em>)^T=(A^T)^</em>$</li><li>$|A^*|=|A|^{n-1}$</li><li>$(A^<em>)^</em>=|A|^{n-2}A(n\geqq2)$</li></ol></li></ol><h3 id="可逆矩阵的概念和定理"><a href="#可逆矩阵的概念和定理" class="headerlink" title="可逆矩阵的概念和定理"></a>可逆矩阵的概念和定理</h3><ol><li><p>概念<br> 对于$n$阶矩阵$A$，如果存在$n$阶矩阵$B$使得</p><script type="math/tex; mode=display"> AB=BA=E</script><p> 则称$A$是可逆矩阵或者非奇异矩阵，$B$称为$A$的逆矩阵，记成$A^{-1}=B$</p></li><li><p>定理</p><ol><li>如果$A$矩阵可逆，则它的逆矩阵唯一<blockquote><p>设B、C都是A的逆矩阵，则有<br>$AB=BA=E$和$AC=CA=E$<br>那么很容易得出<br>$B=BE=B(AC)=(BA)C=EC=C$</p></blockquote></li><li>$A可逆\Leftrightarrow|A|\ne0$<blockquote><p>如果$A$可逆，则存在$A^{-1}$</p><script type="math/tex; mode=display">|A \cdot A^{-1}| = |E| \Rightarrow |A||A^{-1}| = 1</script><p>如果$|A|=0$，由$AA^<em>=A^</em>A=|A|E$可以得到</p><script type="math/tex; mode=display">A \cdot \frac{A^*}{|A|} = \frac{A^*}{|A|} \cdot A =E</script><p>同时也可以得到</p><script type="math/tex; mode=display">A^{-1} = \frac{A^*}{|A|}</script></blockquote></li><li>设$A$和$B$都是$n$阶矩阵且$AB=E$，则有$BA=E$</li></ol></li><li><p>推论</p><ol><li>如果$A$矩阵可逆，则$A^{-1}$也可逆，且$(A^{-1})^{-1}=A$</li><li>如果$A$矩阵可逆，且$k \ne 0$，则$kA$也可逆，且$(kA)^{-1}=\frac{1}{k}A^{-1}$</li><li>如果$A$和$B$均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$</li></ol></li><li><p>求逆矩阵的方法</p><ol><li><script type="math/tex; mode=display">A^{-1} = \frac{A^*}{|A|}</script></li><li>用初等变换法 $(A|B) \Rightarrow (E|A^{-1})$</li><li>使用定义求解</li><li>使用分块矩阵<script type="math/tex; mode=display">  \begin{bmatrix}  A & 0 \\  0 & C \\  \end{bmatrix}^{-1}=  \begin{bmatrix}  A^{-1} & 0 \\  0 & C^{-1} \\  \end{bmatrix}</script></li></ol></li></ol><h2 id="初等变换、初等矩阵"><a href="#初等变换、初等矩阵" class="headerlink" title="初等变换、初等矩阵"></a>初等变换、初等矩阵</h2><h3 id="初等变换与初等矩阵的概念"><a href="#初等变换与初等矩阵的概念" class="headerlink" title="初等变换与初等矩阵的概念"></a>初等变换与初等矩阵的概念</h3><ol><li><p>初等变换</p><p> 初等变换包含倍加，倍乘和互换</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[初等变换]--&gt;B[倍加]</span><br><span class="line">A[初等变换]--&gt;C[倍乘]</span><br><span class="line">A[初等变换]--&gt;D[互换]</span><br></pre></td></tr></table></figure><ol><li>倍乘：用某个非零常数$k(k \ne 0)$乘$A$的某行（列）的每个元素</li><li>倍加：将$A$的某行（列）的元素的$k$倍加到另一行</li><li>互换：互换$A$的某两行（列）的位置</li></ol></li><li><p>初等矩阵<br> 由<strong>单位矩阵</strong>经过一次初等变换所得到的矩阵称为<strong>初等矩阵</strong>，存在下列三种情况：</p><ol><li><p>倍乘初等矩阵，用$E(i(k))$表示，例如</p><script type="math/tex; mode=display">E(2(k))= \begin{bmatrix}     1 & 0 & 0 \\     0 & k & 0 \\     0 & 0 & 1 \end{bmatrix}</script><p> 表示单位矩阵的第二行或者第二列乘$k$倍<br> 对倍乘初等矩阵来说，以上面的示例为例，它的逆矩阵可以表示为</p><script type="math/tex; mode=display">E(2(k))^{-1}= \begin{bmatrix}     1 & 0 & 0 \\     0 & \frac{1}{k} & 0 \\     0 & 0 & 1 \end{bmatrix}</script></li><li><p>互换初等矩阵，用$E(i,j)$表示，例如</p><script type="math/tex; mode=display">E(1,2)= \begin{bmatrix}     0 & 1 & 0 \\     1 & 0 & 0 \\     0 & 0 & 1 \end{bmatrix}</script><p> 表示单位矩阵的第一行和第二行互换，或者第一列和第二列互换<br> 对互换初等矩阵来说，以上面的示例为例，它的逆矩阵可以表示为</p><script type="math/tex; mode=display">E(1,2)^{-1}= \begin{bmatrix}     0 & 1 & 0 \\     1 & 0 & 0 \\     0 & 0 & 1 \end{bmatrix}</script></li><li><p>倍加初等矩阵，用$E(ij(k))$表示，例如</p><script type="math/tex; mode=display">E(13(k))= \begin{bmatrix}     1 & 0 & 0 \\     0 & 1 & 0 \\     k & 0 & 1 \end{bmatrix}</script><p> 表示第一行的$k$倍加到第三行的矩阵<br> 对倍加初等矩阵来说，以上面的示例为例，它的逆矩阵可以表示为</p><script type="math/tex; mode=display">E(13(k))^{-1}= \begin{bmatrix}     1 & 0 & 0 \\     0 & 1 & 0 \\     -k & 0 & 1 \end{bmatrix}</script></li></ol></li><li><p>初等矩阵的左乘和右乘<br> 初等矩阵$P$<strong>左乘</strong>矩阵$A$所得到的结果$PA$，就是矩阵$A$做一次和$P$相同的<strong>行</strong>变换<br> 初等矩阵$P$<strong>右乘</strong>矩阵$A$所得到的结果$AP$，就是矩阵$A$做一次和$P$相同的<strong>列</strong>变换</p></li></ol><h3 id="等价矩阵"><a href="#等价矩阵" class="headerlink" title="等价矩阵"></a>等价矩阵</h3><p>矩阵$A$经过<strong>有限次</strong>的初等变换所得到矩阵$B$，则称$A$和$B$等价，记作$A \cong B$</p><h2 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h2><ol><li><p>概念<br> 将矩阵用若干纵线和横线分成许多小块，每一个小块称为原矩阵的子矩阵或者子块</p></li><li><p>分块矩阵的计算</p><script type="math/tex; mode=display"> \begin{bmatrix} A & 0 \\ 0 & C \\ \end{bmatrix}^{-1}= \begin{bmatrix} A^{-1} & 0 \\ 0 & C^{-1} \\ \end{bmatrix}</script><script type="math/tex; mode=display"> \begin{bmatrix} A & 0 \\ 0 & C \\ \end{bmatrix}^n= \begin{bmatrix} A^n & 0 \\ 0 & C^n \\ \end{bmatrix}</script><script type="math/tex; mode=display"> \begin{bmatrix} A & B \\ C & D \\ \end{bmatrix}^T= \begin{bmatrix} A^T & B^T \\ C^T & D^T \\ \end{bmatrix}</script></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;矩阵的概念和运算&quot;&gt;&lt;a href=&quot;#矩阵的概念和运算&quot; class=&quot;headerlink&quot; title=&quot;矩阵的概念和运算&quot;&gt;&lt;/a&gt;矩阵的概念和运算&lt;/h2&gt;&lt;h3 id=&quot;矩阵的概念&quot;&gt;&lt;a href=&quot;#矩阵的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="线性代数" scheme="https://www.entropy2020.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>行列式</title>
    <link href="https://www.entropy2020.cn/2022/11/16/linear_algebra/determinant/"/>
    <id>https://www.entropy2020.cn/2022/11/16/linear_algebra/determinant/</id>
    <published>2022-11-16T15:16:46.000Z</published>
    <updated>2022-11-29T13:32:22.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行列式的概念"><a href="#行列式的概念" class="headerlink" title="行列式的概念"></a>行列式的概念</h2><p>行列式是一个数，即==不同行不同列元素的代数和==。</p><script type="math/tex; mode=display">\begin{vmatrix}a_1 & b_1 \\a_2 & b_2\end{vmatrix}=a_1b_2-b_1a_2</script><blockquote><p>对于主对角线减副对角线的计算方式，只适用于二阶三阶行列式。</p></blockquote><h3 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h3><p>对于n阶行列式我们要有一个简单的了解：</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11}      & \cdots & a_{1n}      \\\vdots & \ddots & \vdots \\a_{n1}      & \cdots & a_{nn}\end{bmatrix}=\sum_{j_1,j_2,...,j_n}{(-1)^{\tau(j_1,j_2,...,j_n)}a_{1j_1}a_{1j_2}...a_{1j_n}}</script><p>这里的<script type="math/tex">\sum_{j_1,j_2,...,j_n}</script>表示对所有的$n$阶排列进行求和。</p><blockquote><p>1.所谓的排列就是由n个数所构成的一个有序数组，通常用$j_1,j_2,…,j_n$表示n阶排列，显然共有$n!$个$n$阶排列。</p><ol><li>在排列中一个大数排在一个小数之前，就称为一个<strong>逆序</strong>，一个排列中列大数排在小数前面的总数称为逆序数。</li><li>逆序数是奇数为奇排列，总数为偶数为偶排列。</li></ol></blockquote><p>由此很容易得到</p><script type="math/tex; mode=display">\begin{vmatrix}a & 0 & 0 & 0 \\0 & b & 0 & 0 \\0 & 0 & c & 0 \\0 & 0 & 0 & d\end{vmatrix}=abcd</script><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><ol><li>经过转置行列式的值不变。</li><li>倍加值不变。</li><li>两行（列）互换加$-$号。</li><li>某行（列）$K$倍可以提出行列式外。<ol><li>某行（列）的元素全为0，行列式值为0。</li><li>若两行（列）的元素成比例，行列式值为0。</li></ol></li><li>如果行列式某行（或列）是两个元素之和，则可以把行列式拆成两个行列式之和。</li></ol><h2 id="行列式按行（或列）展开公式"><a href="#行列式按行（或列）展开公式" class="headerlink" title="行列式按行（或列）展开公式"></a>行列式按行（或列）展开公式</h2><p>在$n$阶行列式</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11}      & \cdots & a_{1n}      \\\vdots & \ddots & \vdots \\a_{n1}      & \cdots & a_{nn}\end{bmatrix}</script><p>中去除$a<em>{ij}$所在的$i$行$j$列的元素，由剩下的元素构成的行列式称为余子式，记为$M</em>{ij}$，称$(-1)^{i+j}M_{ij}$为代数余子式。</p><p>定理一:$|A|$=某行（列）都有元素×其代数余子式之和。<br>定理二:$n$阶行列式等于它的任意一行（列）元素与另一行对应的代数余子式之和为0。</p><h3 id="特殊型"><a href="#特殊型" class="headerlink" title="特殊型"></a>特殊型</h3><ol><li>主对角线上（下）三角形行列式的值等于主对角线元素的乘积</li><li>副对角线上（下）三角形行列式<br><img src="" alt=""></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;行列式的概念&quot;&gt;&lt;a href=&quot;#行列式的概念&quot; class=&quot;headerlink&quot; title=&quot;行列式的概念&quot;&gt;&lt;/a&gt;行列式的概念&lt;/h2&gt;&lt;p&gt;行列式是一个数，即==不同行不同列元素的代数和==。&lt;/p&gt;
&lt;script type=&quot;math/tex;</summary>
      
    
    
    
    
    <category term="线性代数" scheme="https://www.entropy2020.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>程序中断方式</title>
    <link href="https://www.entropy2020.cn/2022/11/13/computer_organization/co-program-interrupt-mode/"/>
    <id>https://www.entropy2020.cn/2022/11/13/computer_organization/co-program-interrupt-mode/</id>
    <published>2022-11-13T14:47:24.000Z</published>
    <updated>2022-11-16T15:14:12.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU对于中断的处理"><a href="#CPU对于中断的处理" class="headerlink" title="CPU对于中断的处理"></a>CPU对于中断的处理</h2><h3 id="CPU对DMA的处理"><a href="#CPU对DMA的处理" class="headerlink" title="CPU对DMA的处理"></a>CPU对DMA的处理</h3><p>CPU一般会在机器周期结束时刻响应DMA中断。这是因为DMA中断优先级比较高，需要CPU尽快响应。但是CPU至少要把手头的工作忙完（完成基本操作，即<strong>机器周期</strong>），因此会在机器周期后进行响应。</p><h3 id="CPU对于一般中断的响应"><a href="#CPU对于一般中断的响应" class="headerlink" title="CPU对于一般中断的响应"></a>CPU对于一般中断的响应</h3><p>需要满足以下条件：</p><ol><li>IF=1。</li><li>现行指令执行结束。CPU在每一个指令周期的最后一个总线周期的最后一个时钟周期的开始采样中断请求输入线，若有中断请求，则下一步不进入取指令周期，而进入中断响应周期</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CPU对于中断的处理&quot;&gt;&lt;a href=&quot;#CPU对于中断的处理&quot; class=&quot;headerlink&quot; title=&quot;CPU对于中断的处理&quot;&gt;&lt;/a&gt;CPU对于中断的处理&lt;/h2&gt;&lt;h3 id=&quot;CPU对DMA的处理&quot;&gt;&lt;a href=&quot;#CPU对DMA的处理&quot;</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.entropy2020.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>日记（2022-11-13）</title>
    <link href="https://www.entropy2020.cn/2022/11/13/diary/diary_2022_11_13/"/>
    <id>https://www.entropy2020.cn/2022/11/13/diary/diary_2022_11_13/</id>
    <published>2022-11-13T10:39:09.000Z</published>
    <updated>2022-11-13T10:40:38.359Z</updated>
    
    <content type="html"><![CDATA[<p>庆祝一下博客的搭建完成吧，希望之后能保持更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;庆祝一下博客的搭建完成吧，希望之后能保持更新。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="日记" scheme="https://www.entropy2020.cn/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>外部存储</title>
    <link href="https://www.entropy2020.cn/2022/11/13/computer_organization/co-external-storage/"/>
    <id>https://www.entropy2020.cn/2022/11/13/computer_organization/co-external-storage/</id>
    <published>2022-11-13T09:34:11.000Z</published>
    <updated>2022-11-16T15:14:20.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><h3 id="容量计算格式"><a href="#容量计算格式" class="headerlink" title="容量计算格式"></a>容量计算格式</h3><p>$非格式化存储容量=位密度\times内圆周长\times每面磁道数\times记录面数$</p><p>$格式化存储容量=扇区大小\times每磁道扇区数\times每面磁道数\times记录面数$</p><p>$格式化存储容量=扇区大小\times每磁道扇区数\times转速$</p><h3 id="RAID的种类及介绍-1"><a href="#RAID的种类及介绍-1" class="headerlink" title="RAID的种类及介绍[1]"></a>RAID的种类及介绍<a href="#references"><sup>[1]</sup></a></h3><p>RAID 的两个关键目标是提高数据可靠性和 I/O 性能。<br>RAID 的主要有三个关键概念和技术：镜像（ Mirroring ）、数据条带（ Data Stripping ）和数据校验（ Data parity ）。</p><ul><li>镜像，将数据复制到多个磁盘，一方面可以提高可靠性，另一方面可并发从两个或多个副本读取数据来提高读性能。显而易见，镜像的写性能要稍低， 确保数据正确地写到多个磁盘需要更多的时间消耗。</li><li>数据条带，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作， 从而获得非常可观的 I/O 性能提升 。</li><li>数据校验，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。</li></ul><div id="references"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/105597209#">RAID的种类及介绍</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;磁盘存储&quot;&gt;&lt;a href=&quot;#磁盘存储&quot; class=&quot;headerlink&quot; title=&quot;磁盘存储&quot;&gt;&lt;/a&gt;磁盘存储&lt;/h2&gt;&lt;h3 id=&quot;容量计算格式&quot;&gt;&lt;a href=&quot;#容量计算格式&quot; class=&quot;headerlink&quot; title=&quot;容量计算格</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.entropy2020.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令系统</title>
    <link href="https://www.entropy2020.cn/2022/11/12/computer_organization/co-instruction-system/"/>
    <id>https://www.entropy2020.cn/2022/11/12/computer_organization/co-instruction-system/</id>
    <published>2022-11-12T14:32:38.000Z</published>
    <updated>2022-11-13T05:49:27.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><h3 id="复杂指令集计算机CISC（Complex-Instruction-Set-Computer）"><a href="#复杂指令集计算机CISC（Complex-Instruction-Set-Computer）" class="headerlink" title="复杂指令集计算机CISC（Complex Instruction Set Computer）"></a>复杂指令集计算机CISC（Complex Instruction Set Computer）</h3><p>经典CISC指令系统Intel x86，IA64。</p><h3 id="精简指令集计算机RISC（Reduced-Instruction-Set-Computer）"><a href="#精简指令集计算机RISC（Reduced-Instruction-Set-Computer）" class="headerlink" title="精简指令集计算机RISC（Reduced Instruction Set Computer）"></a>精简指令集计算机RISC（Reduced Instruction Set Computer）</h3><blockquote><p>80-20定律：即80%的程序只用到了20%的指令。基于这一发现提出了RISC。</p></blockquote><ol><li>特点<ol><li>优先选取使用频率较高的一些设备。</li><li>采用LOAD/STORE结构。</li><li>大多数指令在一个周期内完成。</li><li>采用简单的指令格式和寻址方式，<strong>指令长度固定</strong>。</li><li>固定的指令格式。</li><li>面向寄存器结构。</li><li>采用硬布线设计。</li><li>注重编译的优化。</li></ol></li></ol><p>经典RISC指令系统ARM，MIPS，RISC-V等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CISC和RISC&quot;&gt;&lt;a href=&quot;#CISC和RISC&quot; class=&quot;headerlink&quot; title=&quot;CISC和RISC&quot;&gt;&lt;/a&gt;CISC和RISC&lt;/h2&gt;&lt;h3 id=&quot;复杂指令集计算机CISC（Complex-Instruction-Set-</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.entropy2020.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统中的数据表示</title>
    <link href="https://www.entropy2020.cn/2022/11/12/computer_organization/co-data-representation/"/>
    <id>https://www.entropy2020.cn/2022/11/12/computer_organization/co-data-representation/</id>
    <published>2022-11-12T08:12:08.000Z</published>
    <updated>2022-11-13T15:07:07.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>根据<strong>IEEE754</strong>对于浮点数的定义，单精度浮点数的真值一般表示为：</p><script type="math/tex; mode=display">N=(-1)^s*2^{e-127}*1.f</script><p>其中数字符 $s$ 为1位， 阶码编码 $e$ 为8位（含1位阶符），尾数编码 $f$ 为23位。</p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><p>一般有下列五步</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[对阶]--&gt;B[尾数加减]--&gt;C[规格化]--&gt;D[舍入]--&gt;E[判溢出]  </pre></div><h4 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h4><p>已知X和Y都是IEEE754标准格式的浮点数。求X+Y和X-Y，结果仍用IEEE754表示。</p><p>$X=0,10010010,00110110100000000000000$<br>$Y=0,10001110,10000100000000000000000$</p><h5 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h5><script type="math/tex; mode=display">[X_{阶数}-Y_{阶数}]_补=[X_{阶数}]_移-[Y_{阶数}]_移</script><p>由此可得到X的阶数比Y的阶数大4。</p><h5 id="尾数加减"><a href="#尾数加减" class="headerlink" title="尾数加减"></a>尾数加减</h5><p>对阶后X和Y的尾数分别为</p><p>$X<em>{尾数}=1.00110110100000000000000$<br>$Y</em>{尾数}=0.00011000010000000000000$</p><p>由此可以得出</p><p>$X+Y=0,10010010,00110110100000000000000$<br>$X-Y=0,10001110,10000100000000000000000$</p><h4 id="浮点数的上溢和下溢处理"><a href="#浮点数的上溢和下溢处理" class="headerlink" title="浮点数的上溢和下溢处理"></a>浮点数的上溢和下溢处理</h4><p>浮点数有<strong>上溢区</strong>和<strong>下溢区</strong>之分，当浮点数的阶码大于最大阶码时，称为==上溢==，此时机器停止运算，进行溢出中断处理；如果阶码小于最小的阶码时，称为==下溢==， 此时溢出的数值非常小，直接强制将浮点数的尾数置为0，可以继续执行运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=&quot;浮点数&quot;&gt;&lt;/a&gt;浮点数&lt;/h2&gt;&lt;h3 id=&quot;IEEE754&quot;&gt;&lt;a href=&quot;#IEEE754&quot; class=&quot;headerlink&quot; title=&quot;IEEE754</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.entropy2020.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>绪论</title>
    <link href="https://www.entropy2020.cn/2022/11/12/computer_organization/co-overview/"/>
    <id>https://www.entropy2020.cn/2022/11/12/computer_organization/co-overview/</id>
    <published>2022-11-12T07:54:10.000Z</published>
    <updated>2022-11-16T15:14:16.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h2><h3 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h3><p>将程序指令存储和数据存储分开的存储器结构</p><p>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并行体系结构，它的主要特点是<strong>将程序和数据存储在不同的存储空间中</strong>，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。</p><p><img src="https://pic.baike.soso.com/ugc/baikepic2/2927/cut-20141010153149-5372975.jpg/0" alt="哈佛结构"></p><h3 id="冯·诺依曼结构"><a href="#冯·诺依曼结构" class="headerlink" title="冯·诺依曼结构"></a>冯·诺依曼结构</h3><p>冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此<strong>程序指令和数据的宽度相同</strong>。</p><p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.aHlwegcIgmy1b5owE2qf_AHaE5?pid=ImgDet&amp;rs=1" alt="冯·诺依曼结构"></p><h2 id="计算机分类及性能描述"><a href="#计算机分类及性能描述" class="headerlink" title="计算机分类及性能描述"></a>计算机分类及性能描述</h2><h3 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h3><h4 id="按用途分类"><a href="#按用途分类" class="headerlink" title="按用途分类"></a>按用途分类</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[按用途分类]--&gt;B[通用计算机]B[通用计算机]--&gt;C[个人计算机]B[通用计算机]--&gt;D[服务器]B[通用计算机]--&gt;E[超级计算器]A[按用途分类]--&gt;F[嵌入式计算机]  </pre></div><h4 id="Flynn分类法-1"><a href="#Flynn分类法-1" class="headerlink" title="Flynn分类法[1]"></a>Flynn分类法<a href="#references"><sup>[1]</sup></a></h4><p>Flynn分类法是按照计算机在执行过程中的信息流特征进行分类的，在程序执行过程中通常存在下列三种信息流。</p><ol><li>指令流（IS）：指机器执行的指令序列。</li><li>数据流（DS）：指令流使用的数据，包括输入数据，中间数据和结果，但不包括输出数据。</li><li>控制流（CS）：指令流进入CU，由CU产生一系列信号，在控制流作用下完成指令。</li></ol><p><strong>Flynn根据不同的指令流和数据流组织方式，把计算机系统分成如下4类<a href="#references"><sup>[2]</sup></a>。</strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[Flynn分类法]--&gt;B[单指令流单数据流]A[Flynn分类法]--&gt;C[单指令流多数据流]A[Flynn分类法]--&gt;D[多指令流单数据流]A[Flynn分类法]--&gt;E[多指令流多数据流]  </pre></div><p><img src="https://picd.zhimg.com/v2-fffa79aaf8c89898e88d51f8461afb3a_1440w.jpg?source=172ae18b" alt="Flynn分类"></p><h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><script type="math/tex; mode=display">加速比=\frac{改进后的系统性能}{改进前的系统性能}=\frac{改进前的系统总执行时间}{改进后的系统总只执行时间}</script><p>可改进比例用 $f_e$ 表示，例如总执行时间为100s，可以优化的时间为20s，则 $f_e$ 的值为0.2。</p><p>可改进部分改进后性能提高程度用 $r_e$ 表示，例如执行时间由20s缩短到5s，则 $r_e$ 的值为4。</p><p>通过上述分析，改进前执行时间为 $T_0$ ，改进后执行时间为 $T_n$ ，则有关系</p><script type="math/tex; mode=display">T_n=T_0(1-f_e+\frac{f_e}{r_e})</script><p>由此可得</p><script type="math/tex; mode=display">S_p=\frac{1}{1-f_e+\frac{f_e}{r_e}}</script><div id="references"><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/413778318#">知乎-Flynn分类法</a><br>[2] <a href="https://bbs.huaweicloud.com/blogs/236183">华为云-Flynn分类法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;存储器结构&quot;&gt;&lt;a href=&quot;#存储器结构&quot; class=&quot;headerlink&quot; title=&quot;存储器结构&quot;&gt;&lt;/a&gt;存储器结构&lt;/h2&gt;&lt;h3 id=&quot;哈佛结构&quot;&gt;&lt;a href=&quot;#哈佛结构&quot; class=&quot;headerlink&quot; title=&quot;哈佛结构&quot;</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.entropy2020.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
